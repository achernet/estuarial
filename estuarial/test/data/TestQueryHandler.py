"""
Unit tests for QueryHandler.

Author: Ben Zaitlen and Ely Spears
"""
import os
import yaml
import shutil
import operator
import unittest
import functools
from os.path import join as pjoin
from estuarial.data.yaml_handler import YamlHandler
from estuarial.data.query_handler import QueryHandler
from estuarial.data.keyword_handler import KeywordHandler
from estuarial.array.arraymanagementclient import ArrayManagementClient

class TestQueryHandler(unittest.TestCase):

    def setUp(self):
        """
        
        """
        self.yaml_handler = YamlHandler()
        self.query_handler = QueryHandler()

        # Hard-coded reference to a Yaml file existing in the custom SQL
        # test directory for unit testing. Do not change unless you know
        # what you're doing.
        self._TEST_DIR = "test"
        self._TEST_FILE = "test_composite.yaml"

        # Test file relative to QueryHandler._FILE_DIR.
        self.custom_sql_test_file = pjoin(self._TEST_DIR, self._TEST_FILE)
        
        # NOTE:
        #     The above test file name should only refer to things in the 
        #     "test/" sub-directory of the array client's known location for
        #     custom SQL.
        if not os.path.split(self.custom_sql_test_file)[0] == self._TEST_DIR:
            message = ("Unit test must only operate on custom SQL files "
                       "stored in the '{}' subdirectory of the custom SQL "
                       "directory. Found {} instead. \n\tIf this file is in "
                       "the test directory, ensure the prefix '{}' is part of "
                       "the file name in the unit test definition.")

            raise ValueError(
                message.format(self._TEST_DIR, 
                               self.custom_sql_test_file, 
                               self._TEST_DIR)
            )
        
        # Expanded full path name.
        self.full_custom_sql_test_file = pjoin(
            self.query_handler._FILE_DIR, 
            self.custom_sql_test_file
        )

        # Full location of the autogen directory that should result from
        # the test yaml file's name and path.
        self.expected_autogen_directory = pjoin(
            self.query_handler._AUTOGEN_DIR,
            (self.query_handler._path_sanitizer(self.custom_sql_test_file) +
             self.query_handler._AUTOGEN_SUFFIX)
        )

    def test__class_constants(self):
        """
        Places checks for the needed class constants. This will force 
        programmers to adjust the unit tests accordingly if they adjust the
        class constant.
        """
        required_class_constants = (
            '_BASE_DIR',
            '_FILE_DIR',
            '_DATA_ROOT', 
            '_AUTOGEN_DIR',
            '_PATH_SEP',
            '_YAML_EXT',
            '_NO_ARG_DOC', 
            '_PARAMS_HEADER',
            '_AUTOGEN_SUFFIX', 
            '_SINGLE_QUERY_HEADER',
            '_DOC', 
            '_QUERY',
            '_CONDITIONALS', 
            '_KW_DELIMITER',
        )

        for class_constant in required_class_constants:
            has_constant = hasattr(self.query_handler, class_constant)
            message = "Failed to find required class constant {}"
            self.assertTrue(has_constant, message.format(class_constant))

    def test__path_sanitizer(self):
        """
        Check that flattening file names for autogen works.
        """
        pass

    def test__publish_queries(self):
        """
        Checks that QueryHandler can create an autogen directory when given a
        path to a composite yaml file and that an OSError isn't generated if
        the directory already exists. Checks that autogen singleton yaml files
        satisfy the yaml validation step so that the written files are valid
        yaml.
        """

        # Helper to safely remove a directory.
        def safe_remove(dir_name):
            print "\nUnit test will remove {}".format(dir_name)

            # Only allow removal of the autogen directory.
            if not (dir_name == self.expected_autogen_directory):
                message = ("For unit tests, only removal of the expected auto",
                           "gen directory is permitted. Tried to remove {}")
                
                raise ValueError(message.format(dir_name))
            
            # Force unit tests to be carried out only on files in the autogen
            # path. Prevents attempts to delete anything not auto-generated.            
            if not (self.query_handler._AUTOGEN_DIR in 
                    self.expected_autogen_directory):
                message = ("Attempted to remove {}, which is not located in "
                           "the autogenerated path {}")

                raise ValueError(
                    message.format(self.expected_autogen_directory,
                                   self.query_handler._AUTOGEN_DIR)
                )

            try:
                shutil.rmtree(dir_name)
            except OSError as os_error:
                if os_error.errno != 2:
                    raise os_error

        # Remove directory that would be autogen created from test yaml file,
        # if it exists. 
        safe_remove(self.expected_autogen_directory)

        # invoke function that should autogen create it, and ensure that it is 
        # created. 
        _ = self.query_handler._publish_queries(self.custom_sql_test_file)

        autogen_directory_created = os.path.isdir(
            self.expected_autogen_directory
        )

        self.assertTrue(autogen_directory_created, 
                        "Failed to create autogen directory.")

        # Execute the function again to ensure no exceptions due to the fact
        # that the autogen directory will already exist at this point, and also
        # to pull in the output arguments for further testing.

        (query_files, # Dict of (function name, autogen file) pairs. 
         type_name,   # Name of the created class.
         type_data,   # Contents of the original composite yaml.
         func_names   # List of function names from the yaml file.
         ) = self.query_handler._publish_queries(self.custom_sql_test_file)

        # Examine and validate each of the autogen-written files.
        for file_name, file_path in query_files.iteritems():
            with open(file_path, 'r') as yaml_stream:

                loaded_data_from_yaml = yaml.load(stream=yaml_stream, 
                                                  Loader=yaml.CLoader)

                is_autogen_valid = (
                    self.yaml_handler.valid_sql_singleton(
                        loaded_data_from_yaml
                    )
                )

                self.assertTrue(is_autogen_valid)

        # Remove the autogenerated directory and files so that the execution of
        # this test method doesn't leave any filesystem side effect.
        safe_remove(self.expected_autogen_directory)

    def test__publish_docstring(self):
        """
        """
        # Create loaded dict from yaml

        with open(self.full_custom_sql_test_file, 'r') as full_yaml:
            loaded_data_from_yaml = yaml.load(stream=full_yaml, 
                                              Loader=yaml.CLoader)

        top_level_key = loaded_data_from_yaml.keys()[0]
        function_level_data = loaded_data_from_yaml[top_level_key]

        # For each function name in the dict, get the results of publishing
        # its arg list and docstring.
        for f_name, f_data in function_level_data.iteritems():
            args, docs = self.query_handler._publish_docstring(f_data)
            manual_conditionals_data = f_data.get(
                self.query_handler._CONDITIONALS, 
                {}
            )

            # Compare the 'conditionals' keys to args to ensure they match.
            self.assertEqual(set(args), set(manual_conditionals_data.keys()))

            # For each conditional, ensure that its doc string made it into
            # the published function docstring.
            for arg in args:
                arg_is_documented = str(manual_conditionals_data[arg]) in docs

            
            # Do some checking on the published doc. 
            # Ensure it contains the function's top-level doc string. 
            # Ensure it contains the sentinel for the Params section. 
            # Ensure it contains each arg's substring.


        pass
    



    def test__function_factory(self):
        """
        """
        pass
        
    def test_create_type_from_yaml(self):
        """
        """
        pass

if __name__ == "__main__":
    unittest.main()
        
